#summary DieselFoam's olika ekvationer med tillhörande kommentarer om beroende

==rhoEqn.H== 
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/rhoEqn.H code]

Körs i roten av `while`-loopen, men anropas även av [Equations#pEqn.H pEqn.H]

{{{
volScalarField Sevap
(
    IOobject
    (
        "Sevap",
        runTime.timeName(),
        mesh,
        IOobject::NO_READ,
        IOobject::NO_WRITE
    ),
    mesh,
    dimensionedScalar("zero", dimensionSet(1, -3, -1, 0, 0), 0.0)
);

for (label i=0; i<Y.size(); i++)
{
    if (dieselSpray.isLiquidFuel()[i])
    {
        Sevap += dieselSpray.evaporationSource(i);
    }
}

{
    solve
    (
        fvm::ddt(rho)
      + fvc::div(phi)
      ==
        Sevap
    );
}
}}}

Det är bara solve som är muterande.

Parallellisering av `for`-loopen m.h.a. är pågående
{{{
#pragma omp parallel for      \  
  default(shared) private(i)  \  
  schedule(static,chunk)      \  
}}}

----

==UEqn.H==
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/UEqn.H code]

Körs i roten av `while`-loopen

{{{
fvVectorMatrix UEqn
(
    fvm::ddt(rho, U)
  + fvm::div(phi, U)
  + turbulence->divDevRhoReff(U)
 ==
    rho*g
  + dieselSpray.momentumSource()
);

if (momentumPredictor)
{
    solve(UEqn == -fvc::grad(p));
}
}}}

Inga tilldelningar alls. Vi måste undersöka vidare vad de olika operatorerna och `solve()` gör, för att kunna förstå vart resultatet från ekvationen sparas.

Eftersom det andra stycket är beroende av det första, måste det hela utföras sekventiellt. Dock kan man med fördel dela upp beräkningarna som blir argument till `UEqn`'s konstruktor. Detta t.ex. med:
{{{
tmp<T> t1, t2;
#sections
{
    #section
        t1 = fvm::ddt(rho, U) + fvm::div(phi, U)
    #section
        t2 = rho*g
    #seciton
        t3 = turbulence->divDevRhoReff(U) == dieselSpray.momentumSource()
}
UEqn(t1 + t3 == t2);
}}}

Ovan fungerar om `operator==` är implementerat som `operator-`, vilket var resultatet av våra efterforskningar. Dock finns många `operator-` implementerade, och vi är osäkra på om dessa utför en matrissubtraktion. Ett annat, säkrare alternativ är:
{{{
fvVectorMatrix *t1;
volVectorField *t2;	

#pragma omp sections
{
    #pragma omp section
        t1 = new fvVectorMatrix(fvm::ddt(rho, U) + fvm::div(phi, U));
    #pragma omp section
        t2 = new volVectorField((rho*g)());
}
#pragma omp sections
{
    #pragma omp section
        *t1 += turbulence->divDevRhoReff(U);
    #pragma omp section
        *t2 += dieselSpray.momentumSource();
}
fvVectorMatrix UEqn(*t1 == *t2);
}}}

----

==YEqn.H==
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/YEqn.H code]

Körs i den yttre av `for`-looparna

{{{
tmp<fv::convectionScheme<scalar> > mvConvection
(
    fv::convectionScheme<scalar>::New
    (
        mesh,
        fields,
        phi,
        mesh.divScheme("div(phi,Yi_h)")
    )
);

{

    label inertIndex = -1;
    volScalarField Yt = 0.0*Y[0];

    for (label i=0; i<Y.size(); i++)
    {
        if (Y[i].name() != inertSpecie)
        {
            volScalarField& Yi = Y[i];

            solve
            (
                fvm::ddt(rho, Yi)
              + mvConvection->fvmDiv(phi, Yi)
              - fvm::laplacian(turbulence->muEff(), Yi)
              ==
                dieselSpray.evaporationSource(i)
              + kappa*chemistry.RR(i),
                mesh.solver("Yi")
            );

            Yi.max(0.0);
            Yt += Yi;
        }
        else
        {
            inertIndex = i;
        }
    }

    Y[inertIndex] = scalar(1) - Yt;
    Y[inertIndex].max(0.0);
}
}}}

Förutom det trolleri som `solve()` åstakommer, ändrar den bara på lokala variabler samt `Y[inertIndex]`. Om man antar att varje slinga har ett unikt `inertIndex`, är det bara `solve()` kvar.

----

==hEqn.H==
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/hEqn.H code]

Körs i den yttre av `for`-looparna

{{{
{
    solve
    (
        fvm::ddt(rho, h)
      + mvConvection->fvmDiv(phi, h)
      - fvm::laplacian(turbulence->alphaEff(), h)
     ==
       DpDt
     + dieselSpray.heatTransferSource()
    );

    thermo.correct();
}
}}}

Det är endast `thermo.correct()` och `solve()` som anropas, kontrollera dessa.

----

==pEqn.H==
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/pEqn.H code]

Körs i den innre `for`-loopen

{{{
rho = thermo.rho();

volScalarField A = UEqn.A();
U = UEqn.H()/A;

if (transonic)
{
    surfaceScalarField phid
    (
        "phid",
        fvc::interpolate(psi)
       *((fvc::interpolate(U) & mesh.Sf()) - fvc::meshPhi(rho, U))
    );

    for (int nonOrth=0; nonOrth<=nNonOrthCorr; nonOrth++)
    {
        fvScalarMatrix pEqn
        (
            fvm::ddt(psi, p)
          + fvm::div(phid, p)
          - fvm::laplacian(rho/A, p)
         ==
            Sevap
        );

        pEqn.solve();

        if (nonOrth == nNonOrthCorr)
        {
            phi == pEqn.flux();
        }
    }
}
else
{
    phi = fvc::interpolate(rho)
         *((fvc::interpolate(U) & mesh.Sf()) - fvc::meshPhi(rho, U));

    for (int nonOrth=0; nonOrth<=nNonOrthCorr; nonOrth++)
    {
        fvScalarMatrix pEqn
        (
            fvm::ddt(psi, p)
          + fvc::div(phi)
          - fvm::laplacian(rho/A, p)
         ==
            Sevap
        );

        pEqn.solve();

        if (nonOrth == nNonOrthCorr)
        {
            phi += pEqn.flux();
        }
    }
}

#include "rhoEqn.H"
#include "compressibleContinuityErrs.H"

U -= fvc::grad(p)/A;
U.correctBoundaryConditions();

DpDt = fvc::DDt(surfaceScalarField("phiU", phi/fvc::interpolate(rho)), p);
}}}

Ändrar på många globala variabler så som `rho`, `phi` och `U`. Inkluderar 2 ytterligare filer, som kan ha beroenden i sig.

Vi har även (för mig) nykomligen `DpDt` insmygandes på slutet. Vad är det för rackare?