#summary DieselFoam's olika ekvationer med tillhörande kommentarer om beroende

==rhoEqn.H== 
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/rhoEqn.H code]

Körs i roten av `while`-loopen, men anropas även av [Equations#pEqn.H pEqn.H]

{{{
volScalarField Sevap
(
    IOobject
    (
        "Sevap",
        runTime.timeName(),
        mesh,
        IOobject::NO_READ,
        IOobject::NO_WRITE
    ),
    mesh,
    dimensionedScalar("zero", dimensionSet(1, -3, -1, 0, 0), 0.0)
);

for (label i=0; i<Y.size(); i++)
{
    if (dieselSpray.isLiquidFuel()[i])
    {
        Sevap += dieselSpray.evaporationSource(i);
    }
}

{
    solve
    (
        fvm::ddt(rho)
      + fvc::div(phi)
      ==
        Sevap
    );
}
}}}
Består av tre delar: `Sevap` skapas, `Sevap` inkrementeras, och `solve()`.

Med stor sannolikhet är det bara solve som är muterande.

----

==UEqn.H==
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/UEqn.H `[`code`]`]

Körs i roten av `while`-loopen

{{{
fvVectorMatrix UEqn
(
    fvm::ddt(rho, U)
  + fvm::div(phi, U)
  + turbulence->divDevRhoReff(U)
 ==
    rho*g
  + dieselSpray.momentumSource()
);

if (momentumPredictor)
{
    solve(UEqn == -fvc::grad(p));
}
}}}

Inga tilldelningar alls. Vi måste undersöka vidare vad de olika operatorerna och `solve()` gör, för att kunna förstå vart resultatet från ekvationen sparas.

----

==YEqn.H==
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/YEqn.H `[`code`]`]
Körs i den yttre av `for`-looparna

{{{
tmp<fv::convectionScheme<scalar> > mvConvection
(
    fv::convectionScheme<scalar>::New
    (
        mesh,
        fields,
        phi,
        mesh.divScheme("div(phi,Yi_h)")
    )
);

{

    label inertIndex = -1;
    volScalarField Yt = 0.0*Y[0];

    for (label i=0; i<Y.size(); i++)
    {
        if (Y[i].name() != inertSpecie)
        {
            volScalarField& Yi = Y[i];

            solve
            (
                fvm::ddt(rho, Yi)
              + mvConvection->fvmDiv(phi, Yi)
              - fvm::laplacian(turbulence->muEff(), Yi)
              ==
                dieselSpray.evaporationSource(i)
              + kappa*chemistry.RR(i),
                mesh.solver("Yi")
            );

            Yi.max(0.0);
            Yt += Yi;
        }
        else
        {
            inertIndex = i;
        }
    }

    Y[inertIndex] = scalar(1) - Yt;
    Y[inertIndex].max(0.0);
}
}}}

Förutom det trolleri som `solve()` åstakommer, ändrar den bara på lokala variabler samt `Y[inertIndex]`. Om man antar att varje slinga har ett unikt `inertIndex`, är det bara `solve()` kvar.

----

==hEqn.H==
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/hEqn.H `[`code`]`]
Körs i den yttre av `for`-looparna

{{{
{
    solve
    (
        fvm::ddt(rho, h)
      + mvConvection->fvmDiv(phi, h)
      - fvm::laplacian(turbulence->alphaEff(), h)
     ==
       DpDt
     + dieselSpray.heatTransferSource()
    );

    thermo.correct();
}
}}}

Det är endast `thermo.correct()` och `solve()` som anropas, kontrollera dessa.

----

==pEqn.H==
[http://code.google.com/p/openfoam-openmp/source/browse/trunk/pEqn.H `[`code`]`]
Körs i den innre `for`-loopen

{{{
rho = thermo.rho();

volScalarField A = UEqn.A();
U = UEqn.H()/A;

if (transonic)
{
    surfaceScalarField phid
    (
        "phid",
        fvc::interpolate(psi)
       *((fvc::interpolate(U) & mesh.Sf()) - fvc::meshPhi(rho, U))
    );

    for (int nonOrth=0; nonOrth<=nNonOrthCorr; nonOrth++)
    {
        fvScalarMatrix pEqn
        (
            fvm::ddt(psi, p)
          + fvm::div(phid, p)
          - fvm::laplacian(rho/A, p)
         ==
            Sevap
        );

        pEqn.solve();

        if (nonOrth == nNonOrthCorr)
        {
            phi == pEqn.flux();
        }
    }
}
else
{
    phi = fvc::interpolate(rho)
         *((fvc::interpolate(U) & mesh.Sf()) - fvc::meshPhi(rho, U));

    for (int nonOrth=0; nonOrth<=nNonOrthCorr; nonOrth++)
    {
        fvScalarMatrix pEqn
        (
            fvm::ddt(psi, p)
          + fvc::div(phi)
          - fvm::laplacian(rho/A, p)
         ==
            Sevap
        );

        pEqn.solve();

        if (nonOrth == nNonOrthCorr)
        {
            phi += pEqn.flux();
        }
    }
}

#include "rhoEqn.H"
#include "compressibleContinuityErrs.H"

U -= fvc::grad(p)/A;
U.correctBoundaryConditions();

DpDt = fvc::DDt(surfaceScalarField("phiU", phi/fvc::interpolate(rho)), p);
}}}

Ändrar på många globala variabler så som `rho`, `phi` och `U`. Inkluderar 2 ytterligare filer, som kan ha beroenden i sig.

Vi har även (för mig) nykomligen `DpDt` insmygandes på slutet. Vad är det för rackare?