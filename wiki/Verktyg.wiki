#summary 2. Verktyg
#labels Rapport

= 2 Verktyg =

Parallellprogrammering innebär djup analys och djup förståelse, ofta även analys av stora mängder kod. Därför är goda verktyg ett måste för att utföra sådant arbete. Dessutom är parallellisering en komplicerad process som kräver att man behärskar många tekniker inom ämnesområdet. Detta inte minst då trådhantering i olika operativsystem ter sig helt olika.

== 2.1 OpenMP ==

OpenMP är ett parallelliseringsramverk för språken C, C++ och Fortran, som underlättar många av de mer komplicerade uppgifterna under ett paralllelliseringsarbete.
"OpenMP is a portable, scalable model that gives shared-memory parallel programmers a simple and flexible interface for developing parallel applications for platforms ranging from the desktop to the supercomputer." (1)

En viktig insikt är att OpenMP inte är en produkt, utan endast en specifikation. Det är upp till varje kompilator för sig att implementera OpenMP. OpenMP-specifikationen utvecklas och godkänns av OpenMP Architecture Review Board, som består av representanter från många IT-jättar så som Microsoft, IBM, Cray, HP, AMD, Intel, Texas Instruments och Oracle. (1)

OpenMP opererar på enskilda kodblock, och inte på ett helt program. Ett parallellt block har ett tillhörande lag av trådar, som utför den inneslutna koden. Om inga direktiv ges vid skapandet av blocket, kommer samtliga trådar i laget att utföra koden. Det är lätt att styra hur trådar skall hantera kod inom ett parallellt block genom att skapa ett kontrollblock inom det parallelliserade blocket. Kontrollblock kan tillexempel vara till för att synkronisera, dela upp arbetet eller specifiera en uppgifts-orienterad struktur.

(1) http://openmp.org/wp/about-openmp/ 2010-05-06

=== 2.1.1 Pragma ===

För C och C++ nyttjar sig OpenMP av förkompileringsdirektivet pragma för att skapa och styra sina parallelliserade block. Pragma är en förkortning av pragmatisk och är till för att låta C/C++-programmerare få tillgång till maskinspecifika egenskaper.

Detta är en stor fördel då kompilatorn ignorerar dessa pragmatiska direktiv om den inte vet vad de innebär. Således kan man kompilera kod som innehåller OpenMP-instruktioner på en kompilator som inte stödjer OpenMP och fortfarande få ett fungerande program som resultat.

=== 2.1.2 Worksharing ===

En av de viktigaste egenskaperna med OpenMP är att dess möjlighet att tillhandahålla en otroligt väl skalande parallellism. Detta genom att de tidigare nämnda uppgifts-uppdelande kontrollblocken, och framförallt möjligheten att låta varje iteration av en for-loop skötas parallellt.

== 2.2 Profilering ==

=== 2.2.1 GProf ===

=== 2.2.1 VampirTrace ===

== 2.3 OpenFOAM ==

OpenFOAM är ett ramverk för att konstruera och definiera simuleringsmiljöer, och tillhandahåller verktyg för att skapa representationer av den fysiska miljön programmet skall köras i och för att visualisera utdata.  Dessutom ges goda möjligheter att representera en fysikalisk eller kemisk process genom att skapa s.k. lösare.

En fysikalisk eller kemisk process kan givetvis ske under många olika förhållanden och i många olika miljöer. Därför kan man med OpenFOAM lätt konfigurera flera olika saker inför en simulation. Förutom att definiera den fysiska miljön och vad som påverkar den, kan man även finjustera med hur stor precision beräkningar under simulationen skall utföras.
 
=== 2.3.1 Programstruktur ===

[http://openfoam.com/docs/user/img/user0x.png]

(`http://openfoam.com/docs/user/img/user0x.png`)

Figuren ovan visar den verkliga arbetsgången för en simulering.

I följande text visas skillnad på kärnan av programmet och lösare som använder sig av kärnan i programmet. Lösare är program som löser specifika problem inom flödesdynamiken. Dessa använder sig av verktyg som har hand om datamanipulering och algebraiska beräkningar. Vidare har man kärnmekanismer och simuleringsfall. Dessa fyra saker utgör de viktigaste aspekterna av OpenFOAM. 

==== 2.3.1.1 Lösare ====

Det finns en uppsjö av lösare som kommer med i programvaran. Denna rapport kommer behandla tre stycken lösare simpleFoam, dieselFoam och pisoFoam. Källkoden för dessa tre ges i appendix.

För att göra en lösare behöver man egentligen bara en algoritm. Därefter behöver man veta vilka delar av algoritmen motsvarar vilka delar i OpenFOAM. Vanligtvis kräver en överföring från algoritm till kod avsevärt mycker mer ansträngning än så här. simpleFoam tas som exempel för att illustrera förfarandet. Nedan följer ett utdrag från openfoamwiki.net http://openfoamwiki.net/index.php/The_SIMPLE_algorithm_in_OpenFOAM -Wuilbert Lopez 2010-05-10 00.50 som förklarar vad simple algoritmen gör.  översätta? -Wuilbert Lopez 2010-05-10 00.51  Jämför den med den riktiga koden som följer direkt efter.

The SIMPLE (Semi-Implicit Method for Pressure-Linked Equations) allows to couple the Navier-Stokes equations with an iterative procedure, which can be summed up as follows:

   # Set the boundary conditions.
   # Solve the discretized momentum equation to compute the intermediate velocity field.
   # Compute the mass fluxes at the cells faces.
   # Solve the pressure equation and apply under-relaxation.
   # Correct the mass fluxes at the cell faces.
   # Correct the velocities on the basis of the new pressure field.
   # Update the boundary conditions.
   # Repeat till convergence.

The steps 4 and 5 can be repeated for a prescribed number of time to correct for non-orthogonality.

    while (runTime.loop())
    {


        #include "readSIMPLEControls.H"
        #include "initConvergenceCheck.H"

        p.storePrevIter();

        // Pressure-velocity SIMPLE corrector
        {
            #include "UEqn.H"
            #include "pEqn.H"
        }

        turbulence->correct();

        runTime.write();


        #include "convergenceCheck.H"
    }

passa på att förklarar tidsloopen, lägg upp den för Per i sektion 3 =) -Wuilbert Lopez 2010-05-10 01.05 

Det riktigt intressanta med dessa lösare är att vem som helst med kunskaper i flödesdynamik ska kunna sätta ihop en egen lösare. Grundkunskaper i programmering ska vara det enda kravet för att klara av detta. Jämför med andra program eller projekt där expert kunskaper kan behövas för att få en funktion eller modul att fungera och använda sig av tidigare verktyg.

==== 2.3.1.2 Verktyg ====

Alla problem som innebär en modell i 2-D eller högre behöver minst ett datagenereringsverktyg, blockMesh. Det tar en fil med beskrivning av modellen och bygger den. Det gör blockMesh m.h.a. kärnmekanismer. Mer om detta i nästa avsnitt. Det finns fler verktyg av den här typen men de kommer inte nämnas i denna rapport. Lösarna själva använder verktyg och de kan variera från lösare till lösare. Ett verktyg som dock är svårt, om inte omöjligt, att klara sig utan är solve. Det är lite förvirrande att en lösare använder sig av ett verktyg som heter just solve. Ansträngning kommer göras för att undvika onödig förvirring. solve får som argument ekvationer (i form av matriser) som beskriver någon egenskap i modellen (hastighet och tryck t.ex.) och beräknar lösningen. Man kan betrakta solve som motorn i varje lösare. Efter att en simulering har körts finns det naturligtvis verktyg för att analysera simuleringen. Det kanske viktigaste av dessa verktyg är paraFoam. Det visar modellen grafiskt och man kan via kontrollknappar stega sig igenom simuleringen. Om en del av simuleringen har gått snett är det relativt enkelt att se det i paraFoam. Det finns även alternativ för att kolla på en specifik variabel såsom tryck över hela modellen.

==== 2.3.1.3 Tutorials ====

OpenFOAM-paketet innehåller en mängd exempelprogram. Detta är speciellt viktigt nu då hemsidan inte ännu är klar. Ett exempelprogram består av en mapp med exempelprogrammets namn och minst två undermappar. Dessa är mapparna constant och system. constant innehåller bland annat själva modellen i en undermapp kallad polymesh. system ska ha tre filer, controlDict, fvSolver och fvSchemes. I controlDict styr du den simulerade tiden. fvSolver ger dig möjlighet att förändra ekvationslösarnas tolerans. fvSchemes anger vilka ekvationslösare som ska användas.
Om exempelprogrammet kräver komplicerade kommandon kommer man finna ett script kallat Allrun. Man kan antingen köra det eller öppna det och lära sig hur exempelprogrammet ska köras.

=== 2.3.2 Hur det funkar ===

För att ge en bättre förståelse skapar vi en egen *_lösare_*. Vi kallar den Elektrogarden. Det är en simulering av Elektrogården på Chalmers Campus Johanneberg. Modellen ska förutom rudimentär form på gården också simulera vind, regn och väggarnas ytbeläggning.2010-05-09 problem när jag la till trappor, tunnel och glasvägg; se utdelat dokument Elektrogården -Wuilbert Lopez 2010-05-09 20.28 

==== 2.3.2.1 Preprocessing ====

Strukturen för Elektrogarden är:
{{{
Elektrogarden
|
---- system
|
---- constant
---- polyMesh
---- blockMeshDict
}}}
visa vad som finns i blockMeshDict? eller appendix? -Wuilbert Lopez 5/9/10 12:46 PM 

 lättare att göra en bild -Wuilbert Lopez 5/9/10 12:45 PM 

==== 2.3.2.2 Running ====

kör man icoFoam.

==== 2.3.2.3 Postprocessing ====

paraFoam