#summary Vårat aldeles eget order-direktiv

= Eftersom #pragma omp ordered inte var till belåtenhet =

== Header ==
{{{
// Includes
#include <omp.h>
#include <iostream>
#include <iomanip>
#include <map>

#define ORDER_START order::get_instance()->start
#define ORDER_END order::get_instance()->end
#define ORDER_TOGGLE order::get_instance()->toggle
#define ORDER_PRINT order::get_instance()->printStamps

class order_obj
{
	public:
		unsigned int turn;
		bool flip;
		order_obj() : turn(0), flip(true) {}
};

class order
{
	private:
		
		std::map<unsigned int, order_obj> turns;
		
		// Singelton
		order() : ok(true) {};
		order(const order&) : ok(true) {};
		static order* instance;

		bool ok;
		
	public:
		void start(const unsigned int section, const unsigned int waitFor);
		void end(const unsigned int section);

		void toggle();
		void toggle(bool);

		static order* get_instance();
};
}}}

== Source ==

{{{
#include "order.hpp"

order* order::instance = NULL;

void order::start(const unsigned int section, const unsigned int waitFor)
{
	if(!ok) return;
	
	if(this->turns.find(section) == this->turns.end()) // Didn't find section
	{
		// Add an order object
		this->turns[section] = order_obj();
	}
	while(this->turns[section].turn != waitFor) ;
}

void order::end(const unsigned int section)
{
	if(!ok) return;
	
	if(this->turns.find(section) == this->turns.end())
	{
		std::cerr << "Must start(" << section << ") before you can end it!" << std::endl;
		throw new std::exception();
	}
	
	#pragma omp critical
	{
		this->turns[section].turn++;
	}
}

void order::toggle()
{
	this->ok = !this->ok;
}
void order::toggle(bool set)
{
	this->ok = set;
}

order* order::get_instance()
{
	return instance ? instance : (instance = new order);
}
}}}